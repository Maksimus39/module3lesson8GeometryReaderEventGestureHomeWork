class DataManager {
    func getCoreTable() -> CoreTable {
        return CoreTable(footer: """
           Приветствую тебя будущий IOS - developer, я учебно - демонстрационный проект и моя задача рассказать тебе о GeometryReader, Events, Gesture. GeometryReader позволяет динамически адаптировать интерфейс под размеры экрана. Events отслеживают действия пользователя в реальном времени. Gestures обрабатывают касания и жесты для создания интерактивного опыта. Вместе они создают мощный инструментарий для современных приложений.
           """,
                         image: "coreTableImage",
                         title: "Начать обучение")
    }
    
    func getTableCustomCell(for gestureType: GestureType) -> [TableCustomCell] {
        switch gestureType {
        case .onAppear:
            return [
                TableCustomCell(title: "onAppear",
                                image: "onappear",
                                description: """
                                    `onAppear` в SwiftUI — модификатор, срабатывающий при рендеринге представления на экране. Это точка входа для инициализации: загрузки данных, запуска анимаций, подписки на события. В отличие от конструктора, он вызывается только когда элемент становится видимым пользователю — например, при переходе по навигации или прокрутке списка.
                                    В React классовые компоненты используют `componentDidMount()` как прямой аналог: оба срабатывают после монтирования в DOM/иерархию отображения и подходят для side effects. Но есть ключевые различия. `onAppear` вызывается каждый раз при появлении (возврат из деталей, переключение табов), тогда как `componentDidMount()` — единожды за жизненный цикл компонента. Для повторяющихся вызовов в современном React используют `useEffect` с зависимостями или библиотеки вроде `react-navigation` с событиями `focus/blur`.
                                    SwiftUI декларативен: `onAppear` — часть описания UI. React imperative в деталях: жизненный цикл управляется через колбэки и хуки. Оба подхода решают одну задачу — реакцию на появление контента — но SwiftUI делает это элегантнее, без разделения логики и разметки. Для бывшего разработчика на React это ощущается как избавление от шаблонного кода в пользу чистой декларативности.
                                    """),
                
            ]
        case .GeometryProxy:
            return [
                TableCustomCell(title: "GeometryProxy",
                                image: "GeometryProxy",
                                description: """
                                    GeometryProxy в SwiftUI — это контейнер для чтения информации о размерах и положении родительского представления. Он предоставляется через замыкание в модификаторе `.background()` или `.overlay()` с использованием `GeometryReader`.
                                    Когда вы пишете `.background(GeometryReader { geometry in ... })`, SwiftUI создает прокси-объект `geometry`. Этот объект позволяет получить доступ к таким параметрам, как:
                                    - Размер (`geometry.size`) — ширина и высота предлагаемого пространства.
                                    - Безопасная зона (`geometry.safeAreaInsets`) — отступы для динамического островка, нижней панели и т.д.
                                    - **Координаты** (`geometry.frame(in: .global)`) — положение вью относительно различных координатных пространств.
                                    Главная задача GeometryProxy — дать дочернему элементу информацию о том, сколько места предоставил родитель. Это позволяет создавать адаптивные интерфейсы, где размеры и расположение элементов рассчитываются динамически. Например, вы можете прочитать ширину контейнера и установить высоту элемента как половину от этого значения.
                                    Важно: GeometryReader "заполняет" все доступное пространство по осям, которые не ограничены модификатором `.fixedSize`. Поэтому прокси чаще всего используют именно в фоновых модификаторах, чтобы не влиять на верстку, а только считывать метрики родительского вью.
                                    """)
            ]
        case.onDisappear:
            return [
                TableCustomCell(title: "onDisappear",
                                image: "onDisappear",
                                description: """
                                    onDisappear — это модификатор представления в SwiftUI, который позволяет выполнить код непосредственно перед тем, как представление исчезнет с экрана. Он является частью жизненного цикла SwiftUI-вью и противоположен модификатору `onAppear`.
                                    Когда представление удаляется из иерархии (например, при закрытии модального окна, возврате к предыдущему экрану в NavigationStack или при условном скрытии через if), SwiftUI автоматически вызывает замыкание, переданное в `onDisappear`. Это дает разработчику возможность выполнить очистку ресурсов, сохранить данные, отменить подписки, остановить анимации или сетевые запросы.
                                    Важно понимать, что `onDisappear` вызывается не только при полном закрытии экрана, но и когда представление временно скрывается (например, при перекрытии другим представлением или при уходе с экрана в таббаре). В отличие от UIKit (где есть четкое разделение между `viewWillDisappear` и `viewDidDisappear`), SwiftUI предоставляет только один модификатор, который срабатывает в момент исчезновения.
                                    Типичные сценарии использования: сохранение черновиков, остановка таймеров, отписка от NotificationCenter, сброс временных состояний или аналитические события об уходе с экрана. Модификатор применяется к любому вью и может использоваться многократно в одной иерархии.
                                    """)
            ]
        case .task:
            return [
                TableCustomCell(title: "task",
                                image: "task",
                                description: """
                                    Task в SwiftUI — это мощный модификатор для выполнения асинхронных операций, тесно связанный с жизненным циклом представления. Появившись в iOS 15, он предоставляет элегантный способ работы с async/await непосредственно в декларативном коде.
                                    Когда вы применяете `.task` к представлению, SwiftUI создает асинхронную задачу, которая запускается автоматически при появлении вью на экране. Главное преимущество — задача автоматически отменяется, когда представление исчезает, что предотвращает утечки памяти и продолжение работы в фоне после ухода с экрана.
                                    Синтаксис предельно прост: `.task { await fetchData() }`. Внутри замыкания можно вызывать любые асинхронные функции — загрузку из сети, работу с базой данных, обработку изображений. Модификатор также поддерживает зависимости: `.task(id: userId) { ... }` будет перезапускать задачу при изменении указанного значения.
                                    Важно понимать, что `task` заменяет комбинацию `onAppear` + ручное управление задачами. Он интегрируется с системой координации SwiftUI и автоматически следит за временем жизни. Если нужно выполнить несколько независимых асинхронных операций, можно использовать вложенные задачи или группы задач внутри замыкания.
                                    Особенно полезен `task` для загрузки начальных данных при открытии экрана, подписки на потоки данных (AsyncSequence, например, WebSocket) или периодического обновления информации с учетом жизненного цикла вью.
                                    """)
            ]
        case .onChange:
            return [
                TableCustomCell(title: "onChange",
                                image: "onChange",
                                description: """
                                    onChange — это модификатор в SwiftUI, который отслеживает изменения указанного значения и выполняет замыкание при каждом его обновлении. Это фундаментальный инструмент для реагирования на изменения состояния в приложении.
                                    Модификатор принимает два параметра: значение для наблюдения (которое должно соответствовать протоколу `Equatable`) и замыкание, которое вызывается при изменении. В замыкание передается либо новое значение (в простой форме), либо как старое, так и новое значение (в расширенной форме): `.onChange(of: score) { oldValue, newValue in ... }`.
                                    Основное назначение `onChange` — выполнение побочных эффектов в ответ на изменения данных. Типичные сценарии: валидация формы при изменении полей, сохранение данных в UserDefaults или CoreData, обновление связанных состояний, отправка аналитических событий, синхронизация с сервером при изменении настроек.
                                    Важное отличие от `onReceive` (который работает с Publisher) в том, что `onChange` оптимизирован специально для `@State`, `@Binding`, `@Published` и других источников истины в SwiftUI. Он срабатывает только при реальном изменении значения, а не при каждом проходе рендеринга.
                                    С iOS 17 появилась возможность использовать `onChange` с двумя версиями замыкания, что делает код чище и предотвращает необходимость хранения предыдущего значения в отдельном состоянии. Модификатор можно применять многократно к разным значениям в одной иерархии представлений.
                                    """)
            ]
        case .TapGesture:
            return [
                TableCustomCell(title: "TapGesture",
                                image: "TapGesture",
                                description: """
                                    TapGesture в SwiftUI — это жест распознавания нажатия, который позволяет реагировать на касания пользователя. Это один из фундаментальных жестов в пользовательском интерфейсе, который преобразует физическое касание экрана в логическое действие.
                                    В своей базовой форме `TapGesture` распознает одно нажатие, но может быть настроен на различное количество нажатий (tap count) и касаний (number of touches). Например, `.onTapGesture(count: 2) { ... }` будет реагировать только на двойное нажатие, а `.simultaneousGesture(TapGesture(count: 1, numberOfTapsRequired: 2))` требует двух пальцев для срабатывания.
                                    Жесты в SwiftUI имеют три ключевые фазы: `onEnded` (выполняется при успешном завершении), `onChanged` (редко используется для tap, чаще для drag) и возможность комбинирования с другими жестами через модификаторы `simultaneousGesture`, `highPriorityGesture` или `gesture`.
                                    Важно понимать, как TapGesture взаимодействует с элементами управления. По умолчанию кнопки и другие интерактивные элементы имеют встроенный обработчик нажатий, но при добавлении кастомного жеста нужно учитывать приоритеты. Модификатор `.onTapGesture` — это удобная обертка, но для тонкой настройки используется непосредственное создание `TapGesture()`.
                                    Типичное применение: кастомные кнопки, ячейки списков, изображения, игровые элементы. Особенность SwiftUI в том, что жест наследует координатное пространство и может получать информацию о позиции касания через `GeometryReader` в комбинации с жестом.
                                    """)
            ]
        case .LongPressGesture:
            return [
                TableCustomCell(title: "LongPressGesture",
                                image: "LongPressGesture",
                                description: """
                                    LongPressGesture в SwiftUI — это жест, распознающий длительное нажатие на элемент интерфейса. В отличие от обычного тапа, он требует удержания пальца на экране в течение определенного времени, что делает его идеальным для действий, требующих подтверждения или раскрывающих дополнительные опции.
                                    Минимальная продолжительность нажатия настраивается параметром `minimumDuration` (в секундах). По умолчанию жест срабатывает через 0.5 секунды, но это значение можно изменить под конкретные задачи. Дополнительно можно указать `maximumDistance` — максимальное расстояние, на которое палец может сместиться во время удержания, чтобы жест все еще считался действительным.
                                    Уникальная особенность `LongPressGesture` — наличие двух фаз: `onChanged` (срабатывает сразу при начале нажатия) и `onEnded` (вызывается после успешного завершения удержания). Это позволяет создавать интересные эффекты — например, визуально подсвечивать элемент при начале нажатия и выполнять основное действие только при успешном завершении.
                                    Жест часто комбинируется с другими жестами или используется для активации контекстных меню (через модификатор `.contextMenu`, который внутри использует long press). Также популярен сценарий "press and hold" для повторяющихся действий, где в `onChanged` можно запускать таймер или анимацию прогресса.
                                    В современных приложениях LongPressGesture применяется для: вызова дополнительного меню, начала режима редактирования, активации перетаскивания элементов, отображения подсказок или удаления элементов без перехода в специальный режим.
                                    """)
            ]
        case .DragGesture:
            return [
                TableCustomCell(title: "DragGesture",
                                image: "DragGesture",
                                description: """
                                    DragGesture в SwiftUI — это жест перетаскивания, который отслеживает движение пальца по экрану. Он является основой для реализации интерактивных интерфейсов, где пользователь может перемещать элементы, изменять их положение или управлять параметрами через свайпы.
                                    Жест предоставляет богатую информацию через свои свойства: `translation` (общее смещение от начала жеста), `location` (текущая позиция касания), `startLocation` (начальная позиция) и `velocity` (скорость движения). Эта информация доступна на всех фазах жеста: `onChanged` вызывается при каждом движении пальца, а `onEnded` — когда пользователь отпускает экран.
                                    Ключевая особенность `DragGesture` — возможность ограничивать направления движения через параметр `minimumDistance`, что позволяет различать тапы (короткие движения) и полноценные перетаскивания. Также можно настроить координатное пространство для получения позиций относительно разных reference frames (глобального, локального или named coordinate spaces).
                                    Практическое применение охватывает широкий спектр задач: перемещение объектов по экрану (drag-and-drop), реализация pull-to-refresh, создание кастомных слайдеров, swipe-жесты для удаления ячеек, интерактивные закрытия модальных окон, панорамирование карт и изображений.
                                    В комбинации с модификаторами `.gesture()` и `.highPriorityGesture()` позволяет точно контролировать приоритеты взаимодействия с другими жестами, а в паре с анимациями и @State создает плавные, отзывчивые интерфейсы с естественной физикой движения.
                                    """)
            ]
        case .ANIMATION:
            return [
                TableCustomCell(title: "Animation",
                                image: "Animation",
                                description: """
                                    Animation в SwiftUI — это система плавных визуальных изменений, которая автоматически интерполирует значения между состояниями интерфейса. В отличие от императивных подходов, где разработчик вручную управляет кадрами, SwiftUI предоставляет декларативный механизм анимации, основанный на изменениях состояния.
                                    Базовый принцип работы: вы описываете конечное состояние интерфейса, а SwiftUI самостоятельно вычисляет промежуточные значения и создает плавный переход. Анимации применяются через модификатор `.animation()` к представлениям или через обертывание изменений состояния в `withAnimation { }`.
                                    SwiftUI предлагает богатую библиотеку встроенных эффектов: `easeInOut`, `linear`, `spring` — каждый с своими характеристиками плавности. Особенно мощны spring-анимации, которые создают естественное, физически правдоподобное движение с эффектами инерции и отскока. Можно настраивать длительность, задержку, количество повторений.
                                    Ключевое понятие — явные и неявные анимации. Неявные применяются автоматически к указанным представлениям при любых изменениях зависимых значений. Явные (`withAnimation`) дают точный контроль над тем, какие изменения анимировать и как.
                                    Для сложных сценариев существуют анимации переходов (`transition`), анимации свойств (`rotationEffect`, `scaleEffect`, `offset`) и matched geometry effect для плавных трансформаций между представлениями. С iOS 17 появился `.phaseAnimator` для пошаговых последовательностей и `KeyframeAnimator` для покадрового контроля. 
                                    """)
            ]
        }
    }
}
